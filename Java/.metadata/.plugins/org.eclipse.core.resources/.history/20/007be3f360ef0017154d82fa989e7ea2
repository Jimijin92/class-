package com.test.collection;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

public class Ex85_Collection {

	public static void main(String[] args) {
		
		//Ex85_Collection.java
		
		//ArrayList, LinkedList, Queue, Stack -> list계열
		
		//Set 계열
		//	- 순서가 없는 배열
		//	- 첨자가 없음 (방번호 X)
		//	- 중복값을 가질 수 없다. 
		
		//HashSet
		//	- Set 인터페이스 구현 
		//	- 순서x, 중복값x
		
		//m1();
		m2();
		
		
		
		
		
		
		
	}

	private static void m2() {
	
		//Set 성질 + 객체 성질 
		
		//단일 값 Set
		//	- 중복값
		Set<String> set1 = new HashSet<String>();
		
		set1.add("홍길동");
		set1.add("아무개");
		set1.add("홍길동"); //중복값 배제
		
		System.out.println(set1);
		
		//복합값(객체) Set  -> 인스턴스들을 집어넣은 Set
		Set<Person> set2 = new HashSet<Person>();
		
		set2.add(new Person("홍길동", 20));
		set2.add(new Person("아무개", 25));
		
		System.out.println(set2);
		
		
	}

	private static void m1() {
		
		//**인터페이스를 구현한 클래스의 객체를 만들 때 참조변수는 인터페이스 변수로 만드는 것이 좋다. 
		//보통 좌우 다를때는 좌측이 인터페이스다.
		
		//HashSet<String> set = new HashSet<String>();
		Set<String> set = new HashSet<String>();
		
		//ArrayList<String> list = new ArrayList<String>();
		List<String> list = new ArrayList<String>();
		
		//요소 추가
		set.add("하나");
		set.add("둘");
		set.add("셋");
		set.add("넷");
		set.add("다섯");
		
		set.add("하나"); //X 안되는게 아니라 무시하는거임 
		
		System.out.println(set.size());
		System.out.println(set); //순서 아무렇게나 나옴 원래..
		
		//로또 번호 추출
		//1. ArrayList
		//2. HashSet
		
		Random rnd = new Random();
		
		ArrayList<Integer> nums1 = new ArrayList<Integer>();
		
		for(int i=0; i<6; i++) {
			int num = rnd.nextInt(45) + 1;
			
			//로또 번호로서 유효한지? 기존의 숫자가 중첩되는지?\
			boolean flag = true;
			
			for(int j=0; j<nums1.size(); j++) {
				if(num == nums1.get(j)) {
					flag = false;
					break;
				}
			}
			
			if(flag) {
				nums1.add(num);
			} else {
				i--; //다시 돌 수 있게 횟수를 하나 줄이기 
			}
	
		}
		
		
		//Collections.sort(nums1);//m1    // 방법 1. 방 하나가 데이터 하나로 되어있으면 이게 더 편함 
		
		nums1.sort(new Comparator<Integer>() {  //방법 2. 

			@Override
			public int compare(Integer o1, Integer o2) {
				// o1이 크면 오름차순 , o2가 크면 내림차순
				return o1 - o2;
			}
			
		});
		
		System.out.println(nums1);
		
		
		
		nums1.clear();
		
		//위의 방법을 살짝 개량
		while (nums1.size() < 6) {
			
			int num = rnd.nextInt(45) + 1;
			
			boolean flag = true;
			
			for(int i=0; i<nums1.size(); i++) {
				if(num == nums1.get(i)) {
					
				}
			}
			
			if(flag) {
				nums1.add(num);
			} 
		}
		
		System.out.println(nums1);
		
		nums1.clear();
		
		//m3 
		ArrayList<Integer> temp = new ArrayList<Integer>();
		
		for(int i=1; i<=45; i++) {
			temp.add(i);
		}
		
		while (nums1.size() < 6) { //번호 추출
			
			//int num = rnd.nextInt(45) + 1; //중복값 발생
			int index = temp.get(rnd.nextInt(temp.size()));
			int num = temp.get(index);
			temp.remove(index); //한번 뽑은 공은 집단에서 제외 
			
			nums1.add(num);
		}
		
		System.out.println(nums1);
		
		
		
		
		//m4 -> ★★★가장 많이 쓰는 방법!
		
		HashSet<Integer> nums2 = new HashSet<Integer>();
		
		while (nums2.size() < 6) { //조건을 횟수가 아닌 사이즈로 돌려야함 
			
			int num = rnd.nextInt(45) + 1;
			nums2.add(num); //중복값 배제
			
		}
		
		//Collections.sort(nums2);
		
		System.out.println(nums2);
		
		//Set -> List 변환
		List<Integer> copy = new ArrayList<Integer>(nums2);
		
		Collections.sort(copy);
		System.out.println(copy);
		
		
		
	}
}

class Person{
	
	private String name;
	private int age;
	
	public Person(String name, int age) {
	
		super();
		this.name = name;
		this.age = age;
	}
	
    public String toString() {
    	return String.format("%s(%d)", this.name, this.age);
    }
	
}
























